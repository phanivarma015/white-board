<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Whiteboard Room</title>

<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.toolbar {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: #1f2937;
  color: white;
  flex-wrap: wrap;
}

.toolbar button {
  padding: 6px 12px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
}

.btn-clear { background: #ef4444; color: white; }

.canvas-container { flex: 1; }

canvas {
  background: white;
  display: block;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  touch-action: none;
}
</style>
</head>

<body>

<div class="toolbar">
  <span>Room: {{ room_name }}</span>

  <label>Color:</label>
  <input type="color" id="colorPicker" value="#000000" />

  <label>Brush:</label>
  <input type="range" id="brushSize" min="1" max="50" value="5" />

  <button class="btn-clear" id="clearBtn">Clear</button>
</div>

<div class="canvas-container">
  <canvas id="canvas"></canvas>
</div>

<script>
const roomName = "{{ room_name }}";

/* ================= WebSocket Setup ================= */

const protocol = window.location.protocol === "https:" ? "wss" : "ws";
const socketUrl = `${protocol}://${window.location.host}/ws/whiteboard/${roomName}/`;

let socket;

function connectSocket() {
  socket = new WebSocket(socketUrl);

  socket.onopen = () => {
    console.log("Whiteboard connected ✅");
  };

  socket.onerror = (e) => {
    console.error("Socket error ❌", e);
  };

  socket.onclose = () => {
    console.log("Socket closed. Reconnecting in 2s...");
    setTimeout(connectSocket, 2000);
  };

  socket.onmessage = function(e) {
    const data = JSON.parse(e.data);

    if (data.type === "draw") {
      drawStrokeSegment(data.segment);
    }

    if (data.type === "clear") {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  };
}

connectSocket();

/* ================= Canvas Setup ================= */

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width = canvas.parentElement.clientWidth;
  canvas.height = canvas.parentElement.clientHeight;
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const colorPicker = document.getElementById("colorPicker");
const brushSize = document.getElementById("brushSize");

let drawing = false;
let lastPoint = null;

/* ================= Mouse Events ================= */

canvas.addEventListener("mousedown", (e) => {
  drawing = true;
  lastPoint = getPosition(e);
});

canvas.addEventListener("mousemove", (e) => {
  if (!drawing) return;
  handleDraw(getPosition(e));
});

canvas.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mouseleave", () => drawing = false);

/* ================= Touch Support (Mobile) ================= */

canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  drawing = true;
  lastPoint = getPosition(e.touches[0]);
});

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (!drawing) return;
  handleDraw(getPosition(e.touches[0]));
});

canvas.addEventListener("touchend", () => drawing = false);

/* ================= Drawing Logic ================= */

function getPosition(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

function handleDraw(newPoint) {
  const segment = {
    color: colorPicker.value,
    width: brushSize.value,
    points: [lastPoint, newPoint]
  };

  drawStrokeSegment(segment);

  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: "draw",
      segment: segment
    }));
  }

  lastPoint = newPoint;
}

function drawStrokeSegment(segment) {
  const points = segment.points;
  if (points.length < 2) return;

  ctx.strokeStyle = segment.color;
  ctx.lineWidth = segment.width;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.stroke();
}

/* ================= Clear ================= */

document.getElementById("clearBtn").addEventListener("click", () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ type: "clear" }));
  }
});
</script>

</body>
</html>
